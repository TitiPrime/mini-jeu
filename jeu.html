<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Avoid Them</title>
  <style>
    body{margin:0;background:#0b1020;color:#fff;font-family:system-ui,Arial;display:grid;place-items:center;height:100vh}
    #wrap{width:min(900px,95vw)}
    canvas{width:100%;height:auto;background:#0f1733;border:2px solid #2a3a7a;border-radius:14px;display:block}
    .hud{display:flex;gap:12px;justify-content:space-between;align-items:center;margin:10px 2px}
    button{padding:10px 14px;border-radius:12px;border:1px solid #2a3a7a;background:#17224a;color:#fff;cursor:pointer}
    button:hover{filter:brightness(1.1)}
    .hint{opacity:.8;font-size:14px}
  </style>
</head>
<body>
<div id="wrap">
  <div class="hud">
    <div><b>Score:</b> <span id="score">0</span> | <b>Record:</b> <span id="best">0</span></div>
    <div class="hint">Déplacements: ← → ↑ ↓ (ou ZQSD)</div>
    <button id="restart">Recommencer</button>
  </div>
  <canvas id="game" width="900" height="520"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const bestEl = document.getElementById("best");
  const restartBtn = document.getElementById("restart");

  const W = canvas.width, H = canvas.height;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const rnd = (a,b)=>a+Math.random()*(b-a);

  let keys = new Set();
  window.addEventListener("keydown", e => keys.add(e.key.toLowerCase()));
  window.addEventListener("keyup", e => keys.delete(e.key.toLowerCase()));

  const bestKey = "mini_avoid_best";
  let best = Number(localStorage.getItem(bestKey) || 0);
  bestEl.textContent = best;

  let player, enemies, t, score, over;

  function reset(){
    player = { x: W/2, y: H/2, r: 16, vx:0, vy:0, speed: 360 };
    enemies = [];
    t = 0;
    score = 0;
    over = false;
    spawnEnemy(true);
    spawnEnemy(true);
    spawnEnemy(true);
    scoreEl.textContent = "0";
  }

  function spawnEnemy(initial=false){
    // Spawn sur un bord pour que ce soit fair
    const side = Math.floor(rnd(0,4));
    let x,y;
    if(side===0){ x = -20; y = rnd(0,H); }
    if(side===1){ x = W+20; y = rnd(0,H); }
    if(side===2){ x = rnd(0,W); y = -20; }
    if(side===3){ x = rnd(0,W); y = H+20; }

    const sp = rnd(120, 220) * (initial ? 1 : 1 + score/80);
    const ang = Math.atan2(player.y - y, player.x - x) + rnd(-0.35, 0.35);
    enemies.push({
      x,y, r: rnd(12,18),
      vx: Math.cos(ang)*sp,
      vy: Math.sin(ang)*sp
    });
  }

  function collide(a,b){
    const dx=a.x-b.x, dy=a.y-b.y;
    const rr=a.r+b.r;
    return (dx*dx+dy*dy) <= rr*rr;
  }

  function input(dt){
    const up = keys.has("arrowup") || keys.has("z");
    const down = keys.has("arrowdown") || keys.has("s");
    const left = keys.has("arrowleft") || keys.has("q") || keys.has("a");
    const right = keys.has("arrowright") || keys.has("d");

    let ax = (right?1:0) - (left?1:0);
    let ay = (down?1:0) - (up?1:0);

    // Normalise diagonale
    const len = Math.hypot(ax,ay) || 1;
    ax/=len; ay/=len;

    player.vx = ax * player.speed;
    player.vy = ay * player.speed;

    player.x = clamp(player.x + player.vx*dt, player.r, W-player.r);
    player.y = clamp(player.y + player.vy*dt, player.r, H-player.r);
  }

  function update(dt){
    if(over) return;

    t += dt;
    score += dt * 10; // points / seconde
    scoreEl.textContent = Math.floor(score);

    // Spawn progressif
    if(t > 1.2){
      t = 0;
      spawnEnemy(false);
    }

    // Update enemies
    for(const e of enemies){
      e.x += e.vx*dt;
      e.y += e.vy*dt;
    }

    // Remove hors écran + marge
    enemies = enemies.filter(e => e.x>-60 && e.x<W+60 && e.y>-60 && e.y<H+60);

    // Collisions
    for(const e of enemies){
      if(collide(player,e)){
        over = true;
        best = Math.max(best, Math.floor(score));
        localStorage.setItem(bestKey, String(best));
        bestEl.textContent = best;
      }
    }
  }

  function draw(){
    // Background
    ctx.clearRect(0,0,W,H);

    // Petites étoiles
    ctx.globalAlpha = 0.25;
    for(let i=0;i<40;i++){
      ctx.beginPath();
      ctx.arc((i*97)%W, (i*173)%H, 1.4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Player
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fillStyle = "#7cf3ff";
    ctx.fill();

    // Enemies
    for(const e of enemies){
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fillStyle = "#ff5f7a";
      ctx.fill();
    }

    // Game Over overlay
    if(over){
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "#fff";
      ctx.font = "bold 52px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", W/2, H/2 - 10);
      ctx.font = "20px system-ui";
      ctx.fillText("Clique sur Recommencer", W/2, H/2 + 32);
      ctx.textAlign = "left";
    }
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    input(dt);
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  restartBtn.addEventListener("click", reset);

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>

